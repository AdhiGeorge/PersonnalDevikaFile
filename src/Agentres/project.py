import os
import json
import zipfile
import asyncio
from datetime import datetime
from typing import Optional
from sqlmodel import Field, Session, SQLModel, create_engine
from Agentres.config.config import Config


class Projects(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    project: str
    message_stack_json: str


class ProjectManager:
    def __init__(self):
        config = Config()
        sqlite_path = config.get_sqlite_db()
        self.project_path = config.get_projects_dir()
        self.engine = create_engine(f"sqlite:///{sqlite_path}")
        SQLModel.metadata.create_all(self.engine)
        self._initialized = False

    async def initialize(self):
        """Initialize async components."""
        try:
            # Create projects directory if it doesn't exist
            os.makedirs(self.project_path, exist_ok=True)
            
            # Ensure database tables are created
            SQLModel.metadata.create_all(self.engine)
            
            self._initialized = True
            print("ProjectManager async components initialized")
        except Exception as e:
            print(f"Failed to initialize async components: {str(e)}")
            raise ValueError(f"Async initialization failed: {str(e)}")

    def new_message(self):
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

        return {
            "from_agent": True,
            "message": None,
            "timestamp": timestamp
        }

    async def create_project(self, project: str):
        try:
            # Ensure async components are initialized
            if not self._initialized:
                await self.initialize()
                
            with Session(self.engine) as session:
                project_state = Projects(project=project, message_stack_json=json.dumps([]))
                session.add(project_state)
                session.commit()
        except Exception as e:
            print(f"Error creating project: {str(e)}")
            raise ValueError(f"Failed to create project: {str(e)}")

    async def delete_project(self, project: str):
        with Session(self.engine) as session:
            project_state = session.query(Projects).filter(Projects.project == project).first()
            if project_state:
                session.delete(project_state)
                session.commit()

    async def add_message_to_project(self, project: str, message: dict):
        with Session(self.engine) as session:
            project_state = session.query(Projects).filter(Projects.project == project).first()
            if project_state:
                message_stack = json.loads(project_state.message_stack_json)
                message_stack.append(message)
                project_state.message_stack_json = json.dumps(message_stack)
                session.commit()
            else:
                message_stack = [message]
                project_state = Projects(project=project, message_stack_json=json.dumps(message_stack))
                session.add(project_state)
                session.commit()

    async def add_message_from_agent(self, project: str, message: str):
        """Persist a message generated by the agent."""
        new_message = self.new_message()
        new_message["message"] = message
        new_message["from_agent"] = True
        await self.add_message_to_project(project, new_message)

    async def add_message_from_user(self, project: str, message: str):
        new_message = self.new_message()
        new_message["message"] = message
        new_message["from_agent"] = False
        await self.add_message_to_project(project, new_message)

    async def get_messages(self, project: str):
        with Session(self.engine) as session:
            project_state = session.query(Projects).filter(Projects.project == project).first()
            if project_state:
                return json.loads(project_state.message_stack_json)
            return None

    async def get_latest_message_from_user(self, project: str):
        with Session(self.engine) as session:
            project_state = session.query(Projects).filter(Projects.project == project).first()
            if project_state:
                message_stack = json.loads(project_state.message_stack_json)
                for message in reversed(message_stack):
                    if not message["from_agent"]:
                        return message
            return None

    async def validate_last_message_is_from_user(self, project: str):
        with Session(self.engine) as session:
            project_state = session.query(Projects).filter(Projects.project == project).first()
            if project_state:
                message_stack = json.loads(project_state.message_stack_json)
                if message_stack:
                    return not message_stack[-1]["from_agent"]
            return False

    async def get_latest_message_from_agent(self, project: str):
        with Session(self.engine) as session:
            project_state = session.query(Projects).filter(Projects.project == project).first()
            if project_state:
                message_stack = json.loads(project_state.message_stack_json)
                for message in reversed(message_stack):
                    if message["from_agent"]:
                        return message
            return None

    async def get_project_list(self):
        with Session(self.engine) as session:
            projects = session.query(Projects).all()
            return [project.project for project in projects]

    async def get_all_messages_formatted(self, project: str):
        formatted_messages = []

        with Session(self.engine) as session:
            project_state = session.query(Projects).filter(Projects.project == project).first()
            if project_state:
                message_stack = json.loads(project_state.message_stack_json)
                for message in message_stack:
                    if message["from_agent"]:
                        formatted_messages.append(f"Agent: {message['message']}")
                    else:
                        formatted_messages.append(f"User: {message['message']}")

            return formatted_messages

    def get_project_path(self, project: str):
        return os.path.join(self.project_path, project.lower().replace(" ", "-"))

    async def project_to_zip(self, project: str):
        project_path = self.get_project_path(project)
        zip_path = f"{project_path}.zip"

        with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
            for root, dirs, files in os.walk(project_path):
                for file in files:
                    relative_path = os.path.relpath(os.path.join(root, file), os.path.join(project_path, '..'))
                    zipf.write(os.path.join(root, file), arcname=relative_path)

        return zip_path

    def get_zip_path(self, project: str):
        return f"{self.get_project_path(project)}.zip"
    
    async def get_project_files(self, project_name: str):
        if not project_name:
            return []

        project_directory = "-".join(project_name.split(" "))
        base_path = os.path.abspath(os.path.join(os.getcwd(), 'data', 'projects'))
        directory = os.path.join(base_path, project_directory)

        # Ensure the directory is within the allowed base path
        if not os.path.exists(directory) or not os.path.commonprefix([directory, base_path]) == base_path:
            return []

        files = []
        for root, _, filenames in os.walk(directory):
            for filename in filenames:
                file_relative_path = os.path.relpath(root, directory)
                if file_relative_path == '.':
                    file_relative_path = ''
                file_path = os.path.join(file_relative_path, filename)
                try:
                    with open(os.path.join(root, filename), 'r') as file:
                        files.append({
                            "file": file_path,
                            "code": file.read()
                        })
                except Exception as e:
                    print(f"Error reading file {filename}: {e}")
        return files

    async def add_code_file(self, project_name: str, filename: str, code: str) -> None:
        """Add a code file to the project directory."""
        project_directory = "-".join(project_name.split(" "))
        base_path = os.path.abspath(os.path.join(os.getcwd(), 'data', 'projects'))
        directory = os.path.join(base_path, project_directory)

        # Create project directory if it doesn't exist
        os.makedirs(directory, exist_ok=True)

        # Write the code to the file
        file_path = os.path.join(directory, filename)
        with open(file_path, 'w') as f:
            f.write(code)


if __name__ == "__main__":
    # Real, practical example usage of the ProjectManager
    async def main():
        try:
            pm = ProjectManager()
            project_name = "Todo List API"
            # Create a new project
            await pm.create_project(project_name)
            print(f"Created project: {project_name}")
            # Add a message from the user
            await pm.add_message_from_user(project_name, "I want to manage todos with a REST API.")
            # Add a message from the agent
            await pm.add_message_from_agent(project_name, "Sure! Let's start by designing the endpoints.")
            # Retrieve all messages
            messages = await pm.get_messages(project_name)
            print("\nAll Messages:")
            for msg in messages:
                print(msg)
            # Get formatted messages
            formatted = await pm.get_all_messages_formatted(project_name)
            print("\nFormatted Messages:")
            for line in formatted:
                print(line)
            # Get project files (will be empty unless files exist)
            files = await pm.get_project_files(project_name)
            print(f"\nProject Files: {files}")
            # Clean up: delete the project
            await pm.delete_project(project_name)
            print(f"Deleted project: {project_name}")
        except Exception as e:
            print(f"Error in project manager example: {str(e)}")

    asyncio.run(main())
